<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo博客搭建记录</title>
    <url>/2021/04/24/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="问题1-Hexo本地博客预览正常，deploy到github之后无格式显示"><a href="#问题1-Hexo本地博客预览正常，deploy到github之后无格式显示" class="headerlink" title="问题1:Hexo本地博客预览正常，deploy到github之后无格式显示"></a>问题1:Hexo本地博客预览正常，deploy到github之后无格式显示</h1><p>我用的是Next主题，在网上找过许多答案，其中一种针对Next主题以前的一个问题所进行的修改：<a href="https://github.com/iissnan/hexo-theme-next/issues/1214">vendors文件修改</a>，但是vendors在随后的Next版本中得到了修改和解决。</p>
<p>如今又出现这样的问题，我根据网上的各种回答进行了许多地方的一个修改，这里做个总结：</p>
]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>TLS-Attacker框架：项目复现</title>
    <url>/2021/04/24/TLS-Attacker%E6%A1%86%E6%9E%B6%EF%BC%9A%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>github project</tag>
      </tags>
  </entry>
  <entry>
    <title>Paper Reading: Scalable Scanning and Automatic Classification of TLS Padding Oracle Vulnerabilities</title>
    <url>/2021/04/24/Paper-Reading-Scalable-Scanning-and-Automatic-Classification-of-TLS-Padding-Oracle-Vulnerabilities/</url>
    <content><![CDATA[<h1 id="「TLS-Padding-Oracle漏洞的可拓展扫描和自动分类」"><a href="#「TLS-Padding-Oracle漏洞的可拓展扫描和自动分类」" class="headerlink" title="「TLS Padding Oracle漏洞的可拓展扫描和自动分类」"></a>「TLS Padding Oracle漏洞的可拓展扫描和自动分类」</h1><p>该论文发表在第28次USS会议上，<a href="https://www.youtube.com/results?search_query=Scalable+Scanning+and+Automatic+Classification+of+TLS+Padding+Oracle+Vulnerabilities">USS会议演讲视频</a>，<a href="https://www.youtube.com/results?search_query=Scalable+Scanning+and+Automatic+Classification+of+TLS+Padding+Oracle+Vulnerabilities">国际密码研究协会演讲视频</a></p>
<p>论文项目也已在Github上开源：<a href="https://github.com/tls-attacker/TLS-Padding-Oracles">TLS Padding Oracles</a></p>
<p>相关：<a href="https://pentesterlab.com/exercises/padding_oracle/course">PentesterLab: Padding Oracle攻击实战</a></p>
<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>TLS协议在现代Internet上提供加密、数据完整性和身份验证。尽管该协议很重要，但目前部署的TLS版本使用的是过时的加密算法，这些算法已被各种攻击攻破。此类攻击的一个突出类别是CBC Padding Oracle（CBC填充预示）攻击。这些攻击使得攻击者能够通过观察取决于CBC填充有效性的不同服务器行为来解密TLS通信数据。</p>
<p>我们首次对现代互联网上TLS实现中的CBC Padding Oracle进行了大规模扫描。我们的扫描显示Alexa排名前百万的网站中有1.83%的网站存在漏洞，且检测到近100个不同的漏洞。我们的扫描仪能观察到服务器行为的细微差别，例如使用不同的TLS Alert或使用不同的TCP Header标志进行响应。</p>
<p>我们使用了一种新的扫描方法，包括三个步骤。首先，我们创建了一大组探探针，以相当高的扫描成本来检测漏洞。然后，我们使用初步扫描减少了探针的数量，使得这样一组较小的探针具有相同的检测率，但足够小，可以用于大规模扫描。最后，我们使用减少的探针集合进行大规模扫描，并用一种新的方法使用图形绘制算法对我们的发现进行了聚类。</p>
<p>与普遍的看法相反，利用CBC Padding Oracle并不一定需要执行精确的计时测量。我们检测到只需观察不同服务器响应的内容即可利用该漏洞。这些漏洞在实践中构成的威胁比之前设想的要大得多。</p>
<h1 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h1><p>在2002年，Vaudenay提出了一种攻击，该攻击的目标是通过密码块链接（CBC）操作模式加密的消息[39]。该攻击利用了CBC模式的可延展性，该模式允许更改密文，以便在不了解加密密钥的情况下翻转特定的明文位。攻击需要服务器解密消息，并根据消息的有效性以1或0响应。这种行为从本质上为攻击者提供了一个加密预言，该预言可用于发起自适应选择密文攻击。攻击者利用这种行为通过执行自适应查询来解密消息。Vaudenay开发出了一种特殊形式的易受攻击的行为，其中的执行会验证CBC填充结构并相应地响应1或0。</p>
<p>此类攻击被称为padding oracle攻击。演示了不同形式的padding oracle攻击可以破坏加密硬件[6]、XML加密[23]或诸如Java Server Faces [33]和ASP.NET Web应用程序[15]之类的Web技术。 Rizzo和Duong使用padding oracle攻击来窃取秘密并伪造身份验证令牌，从而获得对敏感数据的访问权[15]。在所有这些工作中，攻击者能够使用一个直接的侧信道（不同的错误消息）来实例化padding oracle并解密机密数据。</p>
<p>传输层安全（TLS）在MAC-then-Pad-then-Encrypt方案中采用了CBC模式，这使其很可能受到这些攻击。实际上，已经有人使用了不同类型的CBC Padding Oracle来破坏TLS的保密连接[39，4，3，20]。所有这些攻击都要求攻击者执行精确的计时测量。该要求源于TLS协议的属性。建立TLS连接后，所有TLS错误消息均以加密方式发送，并且长度相同。因此，即使攻击者能够使服务器发送不同的错误消息，攻击者通常也无法在不同的加密响应之间进行区分。</p>
<p>由于大多数先前的分析仅基于计时侧信道来分析padding oracle攻击，因此他们需要在本地环境中测试实现。这些评估发现了许多新漏洞[4、3、20]。但是，针对这些漏洞实施适当的对策非常具有挑战性，并且需要复杂的恒定时间来实现。实施此类对策可能会引入新的攻击也就不足为奇了。例如，为了修复Lucky 13 Padding Oracle，OpenSSL密码库引入了一个不同的漏洞，其中OpenSSL以不同的TLS警报消息进行响应[37]。因此，分析实验室环境中的实现需要对不同实现的每个新版本进行费力的测试。这显然是不现实的，因此这种分析是偶尔执行的。</p>
<p>考虑到恒定时间TLS填充验证的复杂性，我们希望在其他实现中也可能引入类似于OpenSSL [37]引入的漏洞。因此，这项工作脱离了上面的实验室分析方法，而是使用大规模Internet扫描来评估CBC Padding Oracle。我们尝试回答以下两个问题：padding oracle漏洞的普遍程度如何？这些攻击是否只能通过使用定时辅助信道来利用？</p>
<ul>
<li><p><strong>贡献：</strong>在我们的工作中，我们采用了一种新颖的扫描方法，该方法能够大规模扫描TLS CBC Padding Oracle。 我们使用这种方法来发现新的Padding Oracle漏洞并执行负责任的披露。 我们确定了近100种不同的Padding Oracle。 我们表明，其中的某些功能可以在没有细微时序侧信道的情况下被利用，因此与最近发现的Padding Oracle相比，在实践中构成了显着更大的威胁。</p>
</li>
<li><p><strong>新的大规模扫描方法：</strong>大规模扫描padding oracle是一项挑战。这种扫描通过发送不同格式错误的输入并观察服务器行为来检测漏洞。如Böck等人所示 [9]，在某些情况下，这些输入仅在使用特定的TLS版本或密码套件时触发漏洞。使用协议版本、密码套件和格式错误的输入的所有可能组合进行扫描是不可行的，因为这将需要与每个扫描主机建立大量连接。我们通过仔细选择一组探针克服了这一限制，从而可以进行有效的大规模扫描。我们系统地分析了先前在文献[39、4、3、20、37、27、25、10、29、28]中描述的padding oracle。然后，我们仔细选择了25个表现出padding oracle格式错误的输入，我们将其称为格式错误的记录。这些TLS记录展示了有效填充和无效填充以及MAC的不同组合，并且是使用TLS-Attacker框架生成的[37]。即使只有25个格式错误的记录，使用格式错误的记录、TLS版本和密码套件的各种组合进行扫描也是不切实际的。我们将这些组合称为测试向量。我们对具有所有测试向量的50,000个随机TLS主机进行了初步扫描。然后，我们减少了测试向量集，以使在初步扫描中发现的所有漏洞仍然由减少的向量集触发。我们能够在三天内使用减少的测试向量集扫描Alexa前100万个网站。与[9]相似，我们的扫描器不仅在TLS层而且在TCP层观察到不同的服务器响应。我们的结果表明，大约1.83％的TLS服务器易受CBC Padding Oracle攻击。</p>
</li>
<li><p><strong>尽可能减少误报：</strong>当主机首次显示易受攻击的行为时，我们将对其进行重新扫描以确保该行为不是扫描伪像。 如果主机在对我们的每个测试向量的三个独立扫描中具有相同的响应，则我们仅认为它是易受攻击的。 根据此标准，不太可能将主机错误地标记为易受攻击的主机。 因此，我们认为我们的脆弱性统计数据是保守的较低估计值。</p>
</li>
<li><p><strong>近100个不同的padding oracle漏洞：</strong>必须将检测到的漏洞进行聚类以通知不同的供应商。到目前为止，这是手动完成的[9]。为了自动实现此目的，我们针对较大的测试向量集重新扫描了易受攻击的主机。我们将宿主对所有测试向量的响应集称为宿主的响应图。此响应图实质上是主机漏洞的指纹。然后，我们根据扫描的主机的响应图对其进行聚类。该过程确定了93个不同的响应图，即93个不同的漏洞。这些漏洞包括不同的行为，范围从具有不同TLS警报消息的典型padding oracle[39]到特定无效MAC字节触发的TCP连接超时，或在使用无效填充值时观察到的关闭连接。我们将不同的响应图视为不同的漏洞，我们认为这是计算漏洞的自然方法，因为它捕获了在相似但不同的实现中发生的相同漏洞的情况。考虑两个主机对所有测试向量的响应相同。这些主机可能共享实现的相同或非常相似的部分，从而导致漏洞显示具有相同的响应图。但是，它们不一定共享相同的代码。他们可能使用同一TLS库的不同版本，或者使用具有共享组件的两个不同的库。</p>
</li>
<li><p><strong>易受攻击主机的有效群集：</strong>在我们向受影响的各方有责任地披露我们的发现之前，我们先根据脆弱性主机的响应图对其进行分组。 为了进一步完善我们的分组服务器，我们使用了一种基于二维力导向图的图形FortAtlas2算法[21]。 该算法使我们能够创建易受攻击的服务器主机的图表，从而有效地处理我们负责的披露流程。</p>
</li>
<li><p><strong>可以利用的新漏洞：</strong>为了利用填充漏洞，攻击者需要区分不同的响应，以区分正确和不正确的填充。 在TLS中通常不是这种情况：即使服务器发送两个不同的警报消息，消息也会被加密，并且攻击者无法观察到差异。 因此，以前的大多数针对TLS的padding oracle攻击都依赖于计时度量来区分不同的错误情况[4、3、20]。 但是，我们表明，许多TLS实现都会显示出正确填充和错误填充之间的明显差异。 例如，在一种错误情况下，服务器可能会优雅地关闭TCP连接，而在另一种情况下，服务器可能会不优雅地关闭它。 同样，某些服务器会根据特定的填充错误发送不同数量的警报消息，两种行为都很容易观察到。</p>
</li>
<li><p><strong>负责人的披露和道德考量：</strong>与受影响的网站所有者合作，我们以负责任的态度向几家脆弱的供应商披露了我们的发现。 成功攻击的结果是，攻击者能够解密在TLS连接中重复传输的秘密值。 通过执行扫描，我们无法重建服务器私钥或其他机密数据。 我们使用伪数据执行扫描，从未尝试解密真实用户流量。 我们以负责任的方式向以下供应商和受影响的各方披露了我们的发现：IBM，Amazon，Slack，Cisco，Citrix，Oracle，Heroku，Netflix，Sonicwall，Venmo和Vine。</p>
</li>
</ul>
<h1 id="二、背景"><a href="#二、背景" class="headerlink" title="二、背景"></a>二、背景</h1><p>TLS协议在现代Internet上提供了机密性、完整性和认证性。该协议的最新版本是TLS 1.3 [31]。在撰写本文时，此版本正在逐步使用。在完全部署TLS 1.3之前，被广泛使用的最新版本是TLS 1.2 [14]。现代的客户端和服务器通常还支持两个以前的版本，即TLS 1.0和1.1 [12，13]。在本文的其余部分中，我们仅讨论1.0至1.2版本，这些版本今天已普遍使用并具有相似的结构。 TLS协议包含两个阶段。在称为握手的第一阶段，客户端和服务器选择将用于会话的密码算法并建立会话密钥。在第二阶段，对等方可以安全地发送和接收应用程序数据，这些数据使用上一阶段中建立的密钥和算法进行加密和身份验证。密码算法的上述选择称为TLS密码套件[14]。更确切地说，密码套件是针对所有必需的加密任务的具体算法选择。密码套件是通过将它们对这些算法的选择进行串联来命名的。例如，密码套件TLS_RSA_WITH_AES_128_CBC_SHA使用RSA公钥加密以便在第一阶段建立共享会话密钥，并且还使用具有128位密钥和基于SHA-1的HMAC的对称AES-CBC加密，以便在第二阶段加密和认证数据。</p>
<h2 id="TLS握手协议"><a href="#TLS握手协议" class="headerlink" title="TLS握手协议"></a>TLS握手协议</h2><p>客户端使用ClientHello消息发起TLS握手。此消息通告客户端支持的TLS版本和密码套件。然后，服务器使用指定所选密码套件的ServerHello消息进行响应。它还在证书消息中发送其证书，并通过ServerHelloDone消息指示传输结束。然后，客户端生成一个称为预主密码的秘密值，在服务器的RSA密钥下对其进行加密，并在ClientKeyExchange消息中发送加密的密文。在共享了预主秘密的知识之后，双方现在基于预主秘密推导要在会话中使用的对称加密和MAC密钥。最后，双方都发送ChangeCipherSpec和Finish消息。ChangeCipherSpec消息通知接收方后续消息将根据会话密钥并使用密码套件中指定的对称加密和HMAC算法进行加密和验证。完成的消息包含基于从预主秘密派生的密钥对所有先前握手消息计算的HMAC。由于此消息是在ChangeCipherSpec消息之后发送的，因此它是会话中使用对称加密和MAC进行加密和验证的第一条消息。如果完成的消息在两端都正确解密和验证，则双方现在都可以安全地交换应用程序数据。</p>
<h2 id="CBC分组密码链接模式"><a href="#CBC分组密码链接模式" class="headerlink" title="CBC分组密码链接模式"></a>CBC分组密码链接模式</h2><p>TLS中可能的加密算法有很多，但本文主要研究的是CBC加密模式。在CBC模式下，每个明文块在被块密码加密之前与前一个密文块进行异或运算。形式上，如果我们用Pi表示明文块（i=0，…），密文块用Ci表示，并且用密钥k下的块密码加密为Enck()，则Ci=Enck(Pi⊕C(i−1))，(i=1，…)。除了第一个块之外的所有块都是如此，在第一个块中没有先前的密文块，相反，该块在加密之前与初始化向量(IV)进行异或运算：C0=Enck(P0⊕IV)。</p>
<ul>
<li><strong>CBC模式的延展性：</strong>CBC模式允许攻击者在不知道对称密钥的情况下执行有意义的明文修改。具体地说，假设攻击者知道原始明文Pi的某个块，并且想要更改密文，使得块i改为解密为Pi’。攻击者可以将先前的密文块C(i−1)更改为C(i−1)=C(i−1)’⊕Pi⊕Pi’。这是以破坏前一个块为代价的，该块现在被解密为攻击者通常无法预测的值。此外，攻击者可以在使用此技术时更改块的顺序。如果攻击者知道明文块Pi并用Ci替换密文块Cj，则块j现在将解密为Pj’=Pi⊕C(i−1)⊕C(j−1)。CBC模式的这种“延展性”特性已经被用于许多密码攻击，也是本文介绍的攻击的基石。</li>
</ul>
<h2 id="TLS记录层"><a href="#TLS记录层" class="headerlink" title="TLS记录层"></a>TLS记录层</h2><p>TLS记录层封装协议消息。本质上，记录层用包含消息长度、消息类型和协议版本的报头包装协议消息。一旦交换了ChangeCipherSpec消息，后续的TLS记录将封装加密的消息。在我们的工作中，我们主要关注使用CBC操作模式的密码套件。这些密码套件使用消息验证码(MAC)来保护TLS记录的真实性，并在CBC模式下使用块密码(例如，AES或3DES)加密应用程序数据。TLS规范规定了MAC-Then-Pad-Then-Encrypt机制[14]。加密器首先计算明文上的MAC，将MAC连接到明文，填充消息以使其长度是块长度的倍数，最后在CBC模式下使用分组密码加密MAC和填充的明文。TLS指定填充字节的精确值，填充明文的最后一个字节指定使用多少个填充字节，不包括最后一个字节。其余填充字节的值与最后一个字节的值相同。例如，如果使用4个填充字节(包括最后一个字节)，则所有4个字节的值将为0x03。为了演示整个过程，如果加密器使用TLS_RSA_WITH_AES_128_CBC_SHA密码套件加密5个字节的数据，他将使用HMAC-SHA(其输出为20字节长，固定长度输出)和AES-CBC。对原始明文应用HMAC-SHA后，连接长度为25字节，适合两个AES 16字节块（AES是分16字节块加密，也即128bit位块加密）。加密器通常会选择最小可行填充量，在本例中为7字节。第一个块包含数据和前11个HMAC字节。第二个块包含剩余的9个HMAC字节和7个字节的填充0x06，见图1。请注意，加密器还可以选择较长的填充，并附加23、39、…或247个填充字节(同时相应地设置填充字节的值)。</p>
<p><img src="/images/USS-2020-paper/Figure-1.jpg" alt="Figure-1：当使用AES-CBC和HMAC-SHA处理5个明文字节时，加密器需要附加20个字节的HMAC-SHA输出和7个字节的填充"></p>
<h1 id="三、Padding-Oracle漏洞的历史"><a href="#三、Padding-Oracle漏洞的历史" class="headerlink" title="三、Padding Oracle漏洞的历史"></a>三、Padding Oracle漏洞的历史</h1><p>SSLv3和TLS中的主要设计失败之一是CBC密码套件中的MAC-then-Pad-then-Encrypt方案规范。 该方案负责对TLS实现的一系列攻击，这些攻击称为padding oracle攻击。 即使在TLS规范[14，第6.2.3.2节]中明确总结了这些对策，但其正确实施仍具有挑战性。</p>
<h2 id="Vaudenay式的Padding-Oracles攻击"><a href="#Vaudenay式的Padding-Oracles攻击" class="headerlink" title="Vaudenay式的Padding Oracles攻击"></a>Vaudenay式的Padding Oracles攻击</h2><h2 id="BEAST攻击模型"><a href="#BEAST攻击模型" class="headerlink" title="BEAST攻击模型"></a>BEAST攻击模型</h2><h2 id="POODLE攻击"><a href="#POODLE攻击" class="headerlink" title="POODLE攻击"></a>POODLE攻击</h2><h2 id="Lucky13和其他时间侧信道攻击"><a href="#Lucky13和其他时间侧信道攻击" class="headerlink" title="Lucky13和其他时间侧信道攻击"></a>Lucky13和其他时间侧信道攻击</h2><h2 id="Bleichenbacher攻击及其变种"><a href="#Bleichenbacher攻击及其变种" class="headerlink" title="Bleichenbacher攻击及其变种"></a>Bleichenbacher攻击及其变种</h2><h1 id="扫描与评估的方法论"><a href="#扫描与评估的方法论" class="headerlink" title="扫描与评估的方法论"></a>扫描与评估的方法论</h1><h1 id="大规模TLS扫描"><a href="#大规模TLS扫描" class="headerlink" title="大规模TLS扫描"></a>大规模TLS扫描</h1><h1 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h1><h1 id="现实可利用的-Padding-Oracle漏洞"><a href="#现实可利用的-Padding-Oracle漏洞" class="headerlink" title="现实可利用的 Padding Oracle漏洞"></a>现实可利用的 Padding Oracle漏洞</h1><h1 id="发现"><a href="#发现" class="headerlink" title="发现"></a>发现</h1><h1 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h1><h1 id="总结和未来工作"><a href="#总结和未来工作" class="headerlink" title="总结和未来工作"></a>总结和未来工作</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1>]]></content>
      <tags>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title>「送你一朵小红花」</title>
    <url>/2021/04/26/%E3%80%8C%E9%80%81%E4%BD%A0%E4%B8%80%E6%9C%B5%E5%B0%8F%E7%BA%A2%E8%8A%B1%E3%80%8D/</url>
    <content><![CDATA[<p><img src="https://img0.utuku.china.com/550x0/ent/20200612/8f5ba9c8-3738-4c6f-bc10-9c64c27d1c58.jpg" alt="刘浩存"></p>
]]></content>
      <tags>
        <tag>movie</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/manifest.json</url>
    <content><![CDATA[{"name":"Koper","short_name":"Koper","start_url":"/","icons":[{"src":"/images/siteicon/android-chrome-36x36.png","sizes":"36x36","type":"image/png"},{"src":"/images/siteicon/android-chrome-48x48.png","sizes":"48x48","type":"image/png"},{"src":"/images/siteicon/android-chrome-72x72.png","sizes":"72x72","type":"image/png"},{"src":"/images/siteicon/android-chrome-96x96.png","sizes":"96x96","type":"image/png"},{"src":"/images/siteicon/android-chrome-144x144.png","sizes":"144x144","type":"image/png"},{"src":"/images/siteicon/android-chrome-192x192.png","sizes":"192x192","type":"image/png"},{"src":"/images/siteicon/android-chrome-256x256.png","sizes":"256x256","type":"image/png"},{"src":"/images/siteicon/android-chrome-384x384.png","sizes":"384x384","type":"image/png"},{"src":"/images/siteicon/android-chrome-512x512.png","sizes":"512x512","type":"image/png"}],"theme_color":"#ffffff","background_color":"#ffffff","display":"standalone"}]]></content>
  </entry>
  <entry>
    <title>archives</title>
    <url>/archives/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>categories</title>
    <url>/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/js/remove-url-exter.js</url>
    <content><![CDATA[//重定向浏览器地址
pjax.site_handleResponse = pjax.handleResponse;
pjax.handleResponse = function(responseText, request, href, options){
  Object.defineProperty(request,'responseURL',{
    value: href
  });
  pjax.site_handleResponse(responseText,request,href,options);
}]]></content>
  </entry>
  <entry>
    <title>about</title>
    <url>/about/index.html</url>
    <content><![CDATA[<p>关于我：</p>
<p>一名在读的打工人，每天的事就是科研科研</p>
<p>同时分享自己在读的生活和一些日常</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/images/siteicon/README.html</url>
    <content><![CDATA[<h1 id="Your-Favicon-Package"><a href="#Your-Favicon-Package" class="headerlink" title="Your Favicon Package"></a>Your Favicon Package</h1><p>This package was generated with <a href="https://realfavicongenerator.net/">RealFaviconGenerator</a> <a href="https://realfavicongenerator.net/change_log#v0.16">v0.16</a></p>
<h2 id="Install-instructions"><a href="#Install-instructions" class="headerlink" title="Install instructions"></a>Install instructions</h2><p>To install this package:</p>
<p>Extract this package in <code>&lt;web site&gt;/images/siteicon/</code>. If your site is <code><a href="http://www.example.com/">http://www.example.com</a></code>, you should be able to access a file named <code><a href="http://www.example.com/images/siteicon/favicon.ico">http://www.example.com/images/siteicon/favicon.ico</a></code>.</p>
<p>Insert the following code in the <code>head</code> section of your pages:</p>
<pre><code>&lt;link rel=&quot;apple-touch-icon&quot; sizes=&quot;180x180&quot; href=&quot;/images/siteicon/apple-touch-icon.png&quot;&gt;
&lt;link rel=&quot;icon&quot; type=&quot;image/png&quot; sizes=&quot;32x32&quot; href=&quot;/images/siteicon/favicon-32x32.png&quot;&gt;
&lt;link rel=&quot;icon&quot; type=&quot;image/png&quot; sizes=&quot;16x16&quot; href=&quot;/images/siteicon/favicon-16x16.png&quot;&gt;
&lt;link rel=&quot;manifest&quot; href=&quot;/images/siteicon/site.webmanifest&quot;&gt;
&lt;link rel=&quot;mask-icon&quot; href=&quot;/images/siteicon/safari-pinned-tab.svg&quot; color=&quot;#5bbad5&quot;&gt;
&lt;link rel=&quot;shortcut icon&quot; href=&quot;/images/siteicon/favicon.ico&quot;&gt;
&lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;Koper&quot;&gt;
&lt;meta name=&quot;application-name&quot; content=&quot;Koper&quot;&gt;
&lt;meta name=&quot;msapplication-TileColor&quot; content=&quot;#c4bdc5&quot;&gt;
&lt;meta name=&quot;msapplication-config&quot; content=&quot;/images/siteicon/browserconfig.xml&quot;&gt;
&lt;meta name=&quot;theme-color&quot; content=&quot;#ffffff&quot;&gt;
</code></pre>
<p><em>Optional</em> - Check your favicon with the <a href="https://realfavicongenerator.net/favicon_checker">favicon checker</a></p>
]]></content>
  </entry>
  <entry>
    <title>tags</title>
    <url>/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
